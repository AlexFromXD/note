# PostgreSQL 索引 fillfactor 參數詳解

PostgreSQL 中的 `fillfactor` 參數是一個重要的性能調優選項，特別是在使用 UUID 主鍵的情境下。本文檔解釋此參數的作用、優化原理及適用場景。

## 基本概念

`fillfactor` 參數定義了表或索引 Page 的初始填充度百分比，範圍為 10-100。

```sql
-- 設置索引的 fillfactor 值為 90%
ALTER INDEX my_index_name SET (fillfactor = 90);
```

- **表的默認值**：100（ Page 完全填滿）
- **索引的默認值**：通常為 90（保留 10% 空間）
- **作用**：控制 Page 初始填充時的空間分配策略

## B-tree 索引 Page 分裂機制

了解 `fillfactor` 需要先理解 B-tree 索引的 Page 分裂：

1. ** Page 結構**：PostgreSQL 的 B-tree 索引由多個 Page 組成，每個 Page 存儲鍵值
2. ** Page 分裂**：當一個 Page 滿了無法插入新值時，會分裂成兩個 Page
3. **分裂過程**：
   - 創建一個新 Page
   - 將原 Page 約一半的數據移到新 Page
   - 更新父 Page 的指針
4. **分裂成本**：這是一個高成本操作，會導致：
   - I/O 增加（寫入新 Page ）
   - 鎖定競爭（分裂時需要高級鎖）
   - 索引碎片增加（ Page 可能只部分填充）

## UUID 與 Page 分裂

UUID 主鍵（尤其是 UUIDv4）在 B-tree 索引中會導致特殊的行為：

### UUIDv4（隨機 UUID）

- **特點**：完全隨機，沒有排序規律
- **影響**：新值會隨機分佈在 B-tree 的任何位置
- **問題**：幾乎每次插入都可能導致 Page 分裂
- **結果**：大量寫入時效能下降嚴重，索引碎片增多

### UUIDv7（時間排序 UUID）

- **特點**：按時間順序遞增
- **影響**：新值通常只會加在 B-tree 的右端
- **優勢**：行為類似自增 ID，但無需序列發生器

## fillfactor 的優化原理

設置 `fillfactor < 100` 時：

### 工作原理

1. **預留空間**：每個 Page 初始填充時保留一定百分比的空間
2. **空間利用**：這些空間可用於未來的插入操作
3. **分裂延遲**：只有當預留空間也用完時才觸發分裂

### 雞蛋盒子的比喻

想像 PostgreSQL 的索引 Page 就像是一個雞蛋分發系統：

#### 情境一：fillfactor = 100（默認值，無預留空間）

- **系統規則**：每個盒子必須裝滿 10 顆雞蛋才發出
- **第 11 顆雞蛋到達時**：您必須停下所有工作，取一個新盒子，將原有的 10 顆雞蛋分成兩堆（大約各 5 顆），分別放在兩個盒子中
- **影響**：這個重新分配過程很慢，且會阻塞所有其他人的雞蛋請求
- **頻率**：每收到第 n+1 個雞蛋就必須進行一次分盒操作

#### 情境二：fillfactor = 90（預留 10% 空間）

- **修改後規則**：每個盒子最初只裝 9 顆雞蛋就發出
- **第 10 顆雞蛋到達時**：可以直接放入預留的空位，不需要分盒
- **第 11 顆雞蛋到達時**：才需要進行分盒操作
- **關鍵點**：雞蛋的分配方式（即 UUID 的分佈特性）決定了效果

#### 對於隨機 UUID（UUIDv4）

想像雞蛋會被隨機送到任何一個盒子：

- 假設有 10 個盒子，每個都有 1 個預留空位（fillfactor = 90）
- 當 10 個新雞蛋到達時，它們會大致均勻分佈到這 10 個盒子
- **結果**：幾乎完全不需要進行分盒操作！

相比之下，如果所有盒子都已滿（fillfactor = 100）：

- 10 個新雞蛋中的每一個都會觸發分盒
- **結果**：10 次分盒操作，效率極低

#### 對於順序 ID（如自增 ID）

想像雞蛋總是按順序送到最後一個盒子：

- 無論 fillfactor 設置多少，雞蛋總是填滿最後一個盒子然後需要分盒
- 所有其他盒子的預留空間永遠不會被使用
- **結果**：預留空間基本浪費，fillfactor 效果有限

### 實際效果（以 fillfactor = 90 為例）

對於隨機分佈的 UUIDv4：

- **初始狀態**：每個 Page 填充 90%，留 10% 空間
- **隨機插入**：新的 UUID 值隨機分佈在各個 Page
- **分攤效應**：10 個新的隨機值有望分佈在不同 Page
- ** Page 利用**：這些新值可使用預留的 10% 空間
- **分裂減少**：理論上可減少高達 90% 的 Page 分裂

## 為什麼 fillfactor 對 UUIDv4 特別有效？

fillfactor 的效果取決於數據的分佈特性：

1. **隨機分佈 + 分散預留空間 = 高效率**

   - UUIDv4 的隨機性使得新值均勻分佈在各 Page
   - 每個 Page 都預留空間，正好對應這種分佈
   - 結果：大多數插入操作都能找到預留空間

   **停車位比喻**：想像 fillfactor = 90 就像是在一個城市的各個區域都保留 10% 的停車位，而不是集中在一處。當車輛（UUID）隨機到達各區域時，總能找到空位，避免了重新規劃停車場（ Page 分裂）的麻煩。

2. **順序增長 ID 的情況**
   - 新值總是添加到索引的同一端
   - 只有最後一個 Page 的預留空間有用
   - 其他 Page 的預留空間永遠不會被使用
   - 結果：fillfactor 對自增 ID 效果有限

## 適用場景比較

| 主鍵類型       | fillfactor 效果 | 推薦設置    |
| -------------- | --------------- | ----------- |
| 自增 ID        | 幾乎無效        | 默認（100） |
| UUIDv4（隨機） | 非常顯著        | 80-90       |
| UUIDv7（時序） | 有限            | 90-95       |

## 真實場景優化建議

### 寫入密集型應用

- **UUIDv4**：設置 fillfactor = 80-90
- **UUIDv7**：可選設置 fillfactor = 90-95
- **效果**：高並發寫入時可提升 10-30% 性能

### 讀取密集型應用

- **空間敏感度高**：使用更高的 fillfactor（如 95）
- **查詢性能優先**：適當降低 fillfactor 減少碎片
- **平衡點**：通常在 90-95 之間

### 空間與性能平衡

- **增加 fillfactor**：減少預留空間，節省磁盤（但增加分裂）
- **降低 fillfactor**：增加預留空間，減少分裂（但增加存儲需求）
- **增量調整**：建議先設 90，根據監控結果逐步調整

## 實際效果案例

在一個典型的高寫入 Web 應用中（每秒數千次插入）：

- **無優化（fillfactor = 100）**：

  - 平均插入延遲：8-12ms
  - 周期性延遲峰值：50-100ms（分裂時）
  - 索引大小：較小，但碎片多

- **優化後（fillfactor = 90）**：
  - 平均插入延遲：5-8ms
  - 延遲峰值減少：最大峰值降至 30ms
  - 索引大小：略增約 5-10%，但碎片更少

## 使用方法

### 創建表時設置

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY,
  username TEXT
) WITH (fillfactor = 90);
```

### 創建索引時設置

```sql
CREATE INDEX users_email_idx ON users (email) WITH (fillfactor = 90);
```

### 修改現有索引

```sql
ALTER INDEX users_pkey SET (fillfactor = 90);
```

### 在基準測試項目中的使用

以下是在 UUID 比較測試中的示例用法：

```sql
-- 對 UUID 索引調整 fillfactor (降低葉頁滿度，減少分裂機率)
ALTER INDEX t_uuidv4_pkey SET (fillfactor = 90);
ALTER INDEX t_uuidv7_pkey SET (fillfactor = 90);
```

## 結論

`fillfactor` 參數是優化 UUID 主鍵表性能的重要手段，特別是對於使用隨機 UUID（UUIDv4）的應用。通過合理設置，可以顯著減少 Page 分裂頻率，提高寫入性能，降低性能波動。

雖然無法完全消除 Page 分裂，但合理的空間預留策略與 UUID 的隨機分佈特性相匹配，可以將分裂帶來的影響降至最低，為高並發寫入場景提供更平穩的性能表現。
